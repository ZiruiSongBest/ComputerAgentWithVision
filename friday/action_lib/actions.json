{
    "open_chrome": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_chrome(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open Google Chrome on macOS.\"\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Executes the system command to open Google Chrome on macOS.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        try:\n            subprocess.run(['open', '-a', 'Google Chrome'], check=True)\n            print(\"Google Chrome has been successfully opened.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open Google Chrome: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# open_chrome()()\n",
        "description": "Execute a system command to open Google Chrome on macOS."
    },
    "open_chrome_and_navigate": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_chrome_and_navigate(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open Google Chrome on macOS and navigate to a specified URL.\"\n\n    def __call__(self, url=\"http://youtube.com\", *args, **kwargs):\n        \"\"\"\n        Executes the system command to open Google Chrome on macOS and navigates to the specified URL.\n\n        Args:\n            url (str): The URL to navigate to. Defaults to \"http://youtube.com\".\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        try:\n            subprocess.run(['open', '-a', 'Google Chrome', url], check=True)\n            print(f\"Google Chrome has been successfully opened and navigated to {url}.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open Google Chrome and navigate to {url}: {e}\")\n",
        "description": "Execute a system command to open Google Chrome on macOS and navigate to a specified URL."
    },
    "open_chrome_and_navigate_to_youtube": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_chrome_and_navigate_to_youtube(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open Google Chrome on macOS and navigate to youtube.com.\"\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Executes the system command to open Google Chrome on macOS and navigates to youtube.com.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        url = \"http://youtube.com\"\n        try:\n            subprocess.run(['open', '-a', 'Google Chrome', url], check=True)\n            print(f\"Google Chrome has been successfully opened and navigated to {url}.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open Google Chrome and navigate to {url}: {e}\")\n",
        "description": "Execute a system command to open Google Chrome on macOS and navigate to youtube.com."
    },
    "create_excel_file": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport xlsxwriter\nimport os\n\nclass create_excel_file(BaseAction):\n    def __init__(self):\n        self._description = \"Create a new Excel file in the specified directory with a given name.\"\n\n    def __call__(self, directory, file_name, *args, **kwargs):\n        \"\"\"\n        Creates a new Excel file in the specified directory with the given file name.\n\n        Args:\n            directory (str): The directory where the Excel file will be created.\n            file_name (str): The name of the Excel file to be created, including the .xlsx extension.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the creation of the Excel file.\n        \"\"\"\n        # Ensure the directory exists\n        if not os.path.exists(directory):\n            os.makedirs(directory)\n        \n        # Change the current working directory to the specified directory\n        os.chdir(directory)\n        \n        # Create the Excel file\n        try:\n            workbook = xlsxwriter.Workbook(file_name)\n            workbook.close()\n            print(f\"Excel file '{file_name}' has been successfully created in {directory}.\")\n        except Exception as e:\n            print(f\"Failed to create Excel file '{file_name}' in {directory}: {e}\")\n",
        "description": "Create a new Excel file in the specified directory with a given name."
    },
    "add_new_sheet": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport openpyxl\nimport os\n\nclass add_new_sheet(BaseAction):\n    def __init__(self):\n        self._description = \"Add a new sheet to an existing Excel file and name the new sheet as desired.\"\n\n    def __call__(self, file_path, sheet_name, *args, **kwargs):\n        \"\"\"\n        Adds a new sheet to the specified Excel file with the given sheet name.\n\n        Args:\n            file_path (str): The path to the Excel file where the new sheet will be added.\n            sheet_name (str): The name of the new sheet to be added.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the addition of the new sheet.\n        \"\"\"\n        # Ensure the Excel file exists\n        if not os.path.exists(file_path):\n            print(f\"Excel file '{file_path}' does not exist.\")\n            return\n        \n        try:\n            # Load the workbook and add a new sheet\n            workbook = openpyxl.load_workbook(file_path)\n            workbook.create_sheet(title=sheet_name)\n            workbook.save(file_path)\n            print(f\"New sheet '{sheet_name}' has been successfully added to {file_path}.\")\n        except Exception as e:\n            print(f\"Failed to add new sheet '{sheet_name}' to {file_path}: {e}\")\n",
        "description": "Add a new sheet to an existing Excel file and name the new sheet as desired."
    },
    "download_zip": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport requests\nimport os\n\nclass download_zip(BaseAction):\n    def __init__(self):\n        self._description = \"Download a ZIP file from a specified URL to the local system.\"\n\n    def __call__(self, url, destination_folder, *args, **kwargs):\n        \"\"\"\n        Downloads a ZIP file from the specified URL and saves it to the destination folder.\n\n        Args:\n            url (str): The URL from which to download the ZIP file.\n            destination_folder (str): The local folder where the ZIP file should be saved.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the download and location of the ZIP file.\n        \"\"\"\n        try:\n            # Ensure the destination folder exists\n            if not os.path.exists(destination_folder):\n                os.makedirs(destination_folder)\n            \n            # Extract the file name from the URL\n            file_name = url.split('/')[-1]\n            destination_path = os.path.join(destination_folder, file_name)\n            \n            # Download the file\n            response = requests.get(url)\n            response.raise_for_status()  # Raises an HTTPError if the response status code is 4XX/5XX\n            \n            # Save the file\n            with open(destination_path, 'wb') as f:\n                f.write(response.content)\n            \n            print(f\"ZIP file downloaded successfully and saved to {destination_path}\")\n        except Exception as e:\n            print(f\"Failed to download the ZIP file: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# download_zip()(\"https://example.com/file.zip\", \"/path/to/destination\")\n",
        "description": "Download a ZIP file from a specified URL to the local system."
    },
    "extract_zip": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport zipfile\nimport os\n\nclass extract_zip(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the contents of a ZIP file to access specific files within.\"\n\n    def __call__(self, zip_file_path, extract_to_folder, *args, **kwargs):\n        \"\"\"\n        Extracts the contents of the specified ZIP file into a designated folder.\n\n        Args:\n            zip_file_path (str): The path to the ZIP file to be extracted.\n            extract_to_folder (str): The folder where the contents of the ZIP file should be extracted.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the extraction of the ZIP file.\n        \"\"\"\n        try:\n            # Ensure the extraction folder exists\n            if not os.path.exists(extract_to_folder):\n                os.makedirs(extract_to_folder)\n            \n            # Extract the ZIP file\n            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(extract_to_folder)\n            \n            print(f\"ZIP file extracted successfully to {extract_to_folder}\")\n        except Exception as e:\n            print(f\"Failed to extract the ZIP file: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# extract_zip()(\"/path/to/zip_file.zip\", \"/path/to/extract_to_folder\")\n",
        "description": "Extract the contents of a ZIP file to access specific files within."
    },
    "analyze_pdf": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport PyPDF2\nimport os\n\nclass analyze_pdf(BaseAction):\n    def __init__(self):\n        self._description = \"Analyze the content of the extracted PDF file to identify applicants and their qualifications.\"\n\n    def __call__(self, pdf_file_path, working_dir=None, *args, **kwargs):\n        \"\"\"\n        Analyzes the content of a PDF file to identify applicants and their qualifications.\n\n        Args:\n            pdf_file_path (str): The path to the PDF file to be analyzed.\n            working_dir (str, optional): The working directory where the PDF file is located. If not provided, uses the current working directory.\n\n        Returns:\n            None, but prints the applicants and their qualifications found in the PDF file.\n        \"\"\"\n        # Set the working directory if provided\n        if working_dir:\n            os.chdir(working_dir)\n        else:\n            working_dir = os.getcwd()\n\n        # Ensure the PDF file exists\n        full_pdf_path = os.path.join(working_dir, pdf_file_path)\n        if not os.path.exists(full_pdf_path):\n            print(f\"PDF file '{pdf_file_path}' does not exist in {working_dir}.\")\n            return\n\n        try:\n            # Open and read the PDF file\n            with open(full_pdf_path, 'rb') as pdf_file:\n                pdf_reader = PyPDF2.PdfReader(pdf_file)\n                num_pages = len(pdf_reader.pages)\n                text = \"\"\n                for page_num in range(num_pages):\n                    page = pdf_reader.pages[page_num]\n                    text += page.extract_text() + \"\\n\"\n                \n                # Analyze the text for applicants and their qualifications\n                # This is a placeholder for the analysis logic\n                # You should replace this with actual analysis code\n                print(\"Applicants and their qualifications found in the PDF:\")\n                print(text)  # Placeholder for actual analysis output\n        except Exception as e:\n            print(f\"Failed to analyze the PDF file: {e}\")\n",
        "description": "Analyze the content of the extracted PDF file to identify applicants and their qualifications."
    },
    "extract_pdf_content": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport PyPDF2\nimport os\n\nclass extract_pdf_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the text content from the PDF file for further analysis.\"\n\n    def __call__(self, pdf_file_path, working_dir=None, *args, **kwargs):\n        \"\"\"\n        Extracts the text content from a specified PDF file located at a given path.\n\n        Args:\n            pdf_file_path (str): The path to the PDF file from which to extract text.\n            working_dir (str, optional): The working directory where the PDF file is located. If not provided, uses the current working directory.\n\n        Returns:\n            str: The extracted text content from the PDF file.\n        \"\"\"\n        # Set the working directory if provided\n        if working_dir:\n            os.chdir(working_dir)\n        else:\n            working_dir = os.getcwd()\n\n        # Ensure the PDF file exists\n        full_pdf_path = os.path.join(working_dir, pdf_file_path)\n        if not os.path.exists(full_pdf_path):\n            print(f\"PDF file '{pdf_file_path}' does not exist in {working_dir}.\")\n            return\n\n        try:\n            # Open and read the PDF file\n            with open(full_pdf_path, 'rb') as pdf_file:\n                pdf_reader = PyPDF2.PdfReader(pdf_file)\n                num_pages = len(pdf_reader.pages)\n                text = \"\"\n                for page_num in range(num_pages):\n                    page = pdf_reader.pages[page_num]\n                    text += page.extract_text() + \"\\n\"\n            \n            print(\"PDF content extracted successfully.\")\n            return text\n        except Exception as e:\n            print(f\"Failed to extract content from the PDF file: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# extract_pdf_content()('/Users/dylan/Desktop/1Res/osc/ComputerAgentWithVision/working_dir/Job Listing.pdf', '/Users/dylan/Desktop/1Res/osc/ComputerAgentWithVision/working_dir')\n",
        "description": "Extract the text content from the PDF file for further analysis."
    },
    "analyze_pdf_content": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport re\n\nclass analyze_pdf_content(BaseAction):\n    def __init__(self):\n        self._description = \"Analyze the extracted text content to identify applicants and their qualifications, and determine which applicants are missing a single qualification.\"\n\n    def __call__(self, extracted_text, *args, **kwargs):\n        \"\"\"\n        Analyzes the extracted text content from a PDF to identify applicants, their qualifications, and those missing only a single qualification.\n\n        Args:\n            extracted_text (str): The text content extracted from the PDF file.\n\n        Returns:\n            list: A list of applicants missing only a single qualification.\n        \"\"\"\n        # Split the text into lines for processing\n        lines = extracted_text.split('\\n')\n        \n        # Placeholder for applicants and their qualifications\n        applicants = {}\n        \n        # Placeholder for applicants missing a single qualification\n        applicants_missing_one_qualification = []\n        \n        # Regex pattern to identify applicant names and qualifications\n        applicant_pattern = re.compile(r'^Name: (.+)$')\n        qualification_pattern = re.compile(r'^Qualifications: (.+)$')\n        \n        current_applicant = None\n        \n        for line in lines:\n            # Check for applicant name\n            name_match = applicant_pattern.match(line)\n            if name_match:\n                current_applicant = name_match.group(1)\n                applicants[current_applicant] = []\n                continue\n            \n            # Check for qualifications\n            qualification_match = qualification_pattern.match(line)\n            if qualification_match and current_applicant:\n                qualifications = qualification_match.group(1).split(', ')\n                applicants[current_applicant].extend(qualifications)\n        \n        # Determine which applicants are missing a single qualification\n        for applicant, qualifications in applicants.items():\n            if len(qualifications) == 1:\n                applicants_missing_one_qualification.append(applicant)\n        \n        # Print the result\n        print(\"Applicants missing only a single qualification:\", applicants_missing_one_qualification)\n        \n        return applicants_missing_one_qualification\n",
        "description": "Analyze the extracted text content to identify applicants and their qualifications, and determine which applicants are missing a single qualification."
    },
    "open_vscode": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_vscode(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open VSCode at a specified path.\"\n\n    def __call__(self, path, *args, **kwargs):\n        \"\"\"\n        Executes the system command to open VSCode at the specified path.\n\n        Args:\n            path (str): The path where VSCode should be opened.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        try:\n            subprocess.run(['open', '-a', 'Visual Studio Code', path], check=True)\n            print(f\"VSCode has been successfully opened at {path}.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open VSCode at {path}: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# open_vscode()('/Users/dylan/Desktop/1Res/osc/ComputerWithVisionMain')\n",
        "description": "Execute a system command to open VSCode at a specified path."
    },
    "check_current_branch": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass check_current_branch(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a git command to check the current branch in the specified directory.\"\n\n    def __call__(self, directory_path, *args, **kwargs):\n        \"\"\"\n        Executes a git command to check the current branch in the specified directory.\n\n        Args:\n            directory_path (str): The path to the directory where the git command should be executed.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints the current git branch.\n        \"\"\"\n        try:\n            result = subprocess.run(['git', '-C', directory_path, 'branch', '--show-current'], check=True, capture_output=True, text=True)\n            print(f\"Current branch in {directory_path}: {result.stdout.strip()}\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to check the current branch in {directory_path}: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# check_current_branch()('/Users/dylan/Desktop/1Res/osc/ComputerWithVisionMain')\n",
        "description": "Execute a git command to check the current branch in the specified directory."
    },
    "fetch_latest_changes": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass fetch_latest_changes(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a git command to fetch the latest changes from the remote repository for the specified directory.\"\n\n    def __call__(self, directory_path, *args, **kwargs):\n        \"\"\"\n        Executes a git command to fetch the latest changes from the remote repository for the specified directory.\n\n        Args:\n            directory_path (str): The path to the directory where the git command should be executed.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the fetch command.\n        \"\"\"\n        try:\n            subprocess.run(['git', '-C', directory_path, 'fetch'], check=True)\n            print(f\"Successfully fetched the latest changes for the repository in {directory_path}.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to fetch the latest changes for the repository in {directory_path}: {e}\")\n",
        "description": "Execute a git command to fetch the latest changes from the remote repository for the specified directory."
    },
    "check_if_up_to_date": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass check_if_up_to_date(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a git command to check if the local branch is up to date with its corresponding remote branch.\"\n\n    def __call__(self, directory_path, *args, **kwargs):\n        \"\"\"\n        Executes a git command to check if the local branch is up to date with its corresponding remote branch in the specified directory.\n\n        Args:\n            directory_path (str): The path to the directory where the git command should be executed.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message indicating whether the local branch is up to date with the remote branch.\n        \"\"\"\n        try:\n            # Fetch the latest changes first to ensure the comparison is up to date\n            subprocess.run(['git', '-C', directory_path, 'fetch'], check=True)\n            # Check the status of the local branch in comparison to the remote branch\n            result = subprocess.run(['git', '-C', directory_path, 'status', '-uno'], check=True, capture_output=True, text=True)\n            if \"Your branch is up to date\" in result.stdout:\n                print(f\"The local branch in {directory_path} is up to date with its corresponding remote branch.\")\n            else:\n                print(f\"The local branch in {directory_path} is not up to date with its corresponding remote branch.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to check if the local branch is up to date in {directory_path}: {e}\")\n\n# Example of how to use the class (Do not directly copy this line into your code):\n# check_if_up_to_date()('/Users/dylan/Desktop/1Res/osc/ComputerWithVisionMain')\n",
        "description": "Execute a git command to check if the local branch is up to date with its corresponding remote branch."
    },
    "open_system_preferences": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_system_preferences(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open System Preferences on macOS.\"\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Executes the system command to open System Preferences on macOS.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        try:\n            # Attempt to open System Preferences using the correct path for macOS\n            subprocess.run(['open', '-a', 'System Preferences'], check=True)\n            print(\"System Preferences has been successfully opened.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open System Preferences: {e}\")\n        except Exception as e:\n            # Handle unexpected errors\n            print(f\"An unexpected error occurred: {e}\")\n",
        "description": "Execute a system command to open System Preferences on macOS."
    },
    "open_google_chrome": {
        "code": "\nfrom friday.action.base_action import BaseAction\nimport subprocess\n\nclass open_google_chrome(BaseAction):\n    def __init__(self):\n        self._description = \"Execute a system command to open Google Chrome on macOS.\"\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Executes the system command to open Google Chrome on macOS.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            None, but prints a message confirming the execution of the command.\n        \"\"\"\n        try:\n            subprocess.run(['open', '-a', 'Google Chrome'], check=True)\n            print(\"Google Chrome has been successfully opened.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to open Google Chrome: {e}\")\n",
        "description": "Execute a system command to open Google Chrome on macOS."
    }
}